# ๐ ุดุฑุญ ุดุงูู ููุฎูุงุฑุฒููุงุช ุงูุฃุฑุจุน

## ูุธุฑุฉ ุนุงูุฉ

ูุฐุง ุงูุชุทุจูู ูุณุชุฎุฏู ุฃุฑุจุน ุฎูุงุฑุฒููุงุช ูุฎุชููุฉ ูุญู ุงููุชุงูุงุช:
1. **Stack (DFS)** - Depth-First Search (ุงูุจุญุซ ุจุงูุนูู)
2. **Queue (BFS)** - Breadth-First Search (ุงูุจุญุซ ุจุงูุนุฑุถ)
3. **Linked List** - Sequential Traversal (ุงูุงุฌุชูุงุฒ ุงููุชุณูุณู)
4. **A* (AI)** - A* Search Algorithm (ุฎูุงุฑุฒููุฉ ุงูุจุญุซ ุงูุฐููุฉ) ๐ค

---

## 1๏ธโฃ Stack (DFS) - Depth-First Search

### ุงููุจุฏุฃ ุงูุฃุณุงุณู
**LIFO (Last In First Out)** - ุขุฎุฑ ุนูุตุฑ ูุฏุฎู ูู ุฃูู ุนูุตุฑ ูุฎุฑุฌ

### ููู ูุนูู:

```
ุงูุฎุทูุงุช:
1. ูุจุฏุฃ ูู ููุทุฉ ุงูุจุฏุงูุฉ ููุถูููุง ููู Stack (Push)
2. ูุฃุฎุฐ ุงูุนูุตุฑ ูู ุฃุนูู ุงูู Stack (ุขุฎุฑ ุนูุตุฑ ุฃุถููุงู)
3. ููุญุต ุงูุฌูุฑุงู (ุฃุนููุ ุฃุณููุ ููููุ ูุณุงุฑ)
4. ุฅุฐุง ูุฌุฏูุง ุฌุงุฑ ุตุงูุญ:
   - ูุถููู ููู Stack (Push ูู ุงูููุงูุฉ)
   - ูุฒูุฑู ููุณุชูุฑ ููุฃูุงู
5. ุฅุฐุง ูู ูุฌุฏ ุฌูุฑุงู:
   - ูุฑุฌุน ููุฎูู (Pop ูู ุงูููุงูุฉ)
   - ูุณุชูุฑ ูู ุงูุนูุตุฑ ุงูุณุงุจู
6. ููุฑุฑ ุญุชู ูุตู ููููุงูุฉ ุฃู ููุดู
```

### ุงูููุฏ:

```java
private boolean stepStack() {
    if (stack.isEmpty()) {
        algorithmState = AlgorithmState.NO_PATH;
        return false;
    }

    // ุงูุญุตูู ุนูู ุงูุนูุตุฑ ูู ุงูููุงูุฉ (LIFO)
    Position current = stack.get(stack.size() - 1);

    // ุงูุชุญูู ูู ุงููุตูู ููููุงูุฉ
    if (current.getX() == end.getX() && current.getY() == end.getY()) {
        // ุฑุณู ุงููุณุงุฑ (ุงูู Stack ูุญุชูู ุนูู ุงููุณุงุฑ)
        for (Position pos : stack) {
            updateCellState(pos.getX(), pos.getY(), CellState.PATH);
        }
        return false;
    }

    List<Position> neighbors = getNeighbors(current);

    if (!neighbors.isEmpty()) {
        // Push: ุฅุถุงูุฉ ูู ุงูููุงูุฉ
        Position next = neighbors.get(0);
        visited.add(posToKey(next));
        stack.add(next);
        return true;
    } else {
        // Pop: ุฅุฒุงูุฉ ูู ุงูููุงูุฉ
        stack.remove(stack.size() - 1);
        return !stack.isEmpty();
    }
}
```

### ุงูุฎุตุงุฆุต:
- โ **ูุณุชูุดู ุจุนูู** - ูุฐูุจ ูุฃุจุนุฏ ููุทุฉ ููููุฉ ูุจู ุงูุฑุฌูุน
- โ **ูุณุชุฎุฏู Backtracking** - ูุฑุฌุน ููุฎูู ุนูุฏ ุทุฑูู ูุณุฏูุฏ
- โ **ุงููุณุงุฑ ูู ุงูู Stack** - ุนูุฏ ุงููุตูู ููููุงูุฉุ ุงูู Stack ูุญุชูู ุนูู ุงููุณุงุฑ ุงููุงูู
- โ๏ธ **ูุฏ ูุง ูุนุทู ุฃูุตุฑ ูุณุงุฑ** - ูุฌุฏ ุฃู ูุณุงุฑุ ููุณ ุจุงูุถุฑูุฑุฉ ุงูุฃูุตุฑ

---

## 2๏ธโฃ Queue (BFS) - Breadth-First Search

### ุงููุจุฏุฃ ุงูุฃุณุงุณู
**FIFO (First In First Out)** - ุฃูู ุนูุตุฑ ูุฏุฎู ูู ุฃูู ุนูุตุฑ ูุฎุฑุฌ

### ููู ูุนูู:

```
ุงูุฎุทูุงุช:
1. ูุจุฏุฃ ูู ููุทุฉ ุงูุจุฏุงูุฉ ููุถูููุง ููู Queue (Enqueue)
2. ูุฃุฎุฐ ุงูุนูุตุฑ ูู ุจุฏุงูุฉ ุงูู Queue (ุฃูู ุนูุตุฑ)
3. ููุญุต ุฌููุน ุงูุฌูุฑุงู
4. ููู ุฌุงุฑ ุตุงูุญ:
   - ูุถููู ููู Queue (Enqueue ูู ุงูููุงูุฉ)
   - ูุญูุธ "ุงูุฃุจ" (Parent) ููู ุฌุงุฑ
5. ูุฒูู ุงูุนูุตุฑ ุงูุญุงูู ูู ุงูู Queue (Dequeue ูู ุงูุจุฏุงูุฉ)
6. ููุฑุฑ ุญุชู ูุตู ููููุงูุฉ
7. ุนูุฏ ุงููุตูู ููููุงูุฉ: ูุณุชุฎุฏู Parent Map ูุฅุนุงุฏุฉ ุจูุงุก ุงููุณุงุฑ
```

### ุงูููุฏ:

```java
private boolean stepQueue() {
    if (queue.isEmpty()) {
        algorithmState = AlgorithmState.NO_PATH;
        return false;
    }

    // Dequeue: ุฅุฒุงูุฉ ูู ุงูุจุฏุงูุฉ (FIFO)
    Position current = queue.remove(0);

    // ุงูุชุญูู ูู ุงููุตูู ููููุงูุฉ
    if (current.getX() == end.getX() && current.getY() == end.getY()) {
        // ุฅุนุงุฏุฉ ุจูุงุก ุงููุณุงุฑ ุนุจุฑ Parent Map
        List<Position> path = reconstructPath(current);
        for (Position pos : path) {
            updateCellState(pos.getX(), pos.getY(), CellState.PATH);
        }
        return false;
    }

    // ุงุณุชูุดุงู ุฌููุน ุงูุฌูุฑุงู
    List<Position> neighbors = getNeighbors(current);
    for (Position neighbor : neighbors) {
        if (!visited.contains(posToKey(neighbor))) {
            visited.add(posToKey(neighbor));
            queue.add(neighbor);  // Enqueue
            parentMap.put(posToKey(neighbor), current);  // ุญูุธ ุงูุฃุจ
        }
    }

    return !queue.isEmpty();
}

// ุฅุนุงุฏุฉ ุจูุงุก ุงููุณุงุฑ
private List<Position> reconstructPath(Position endPos) {
    List<Position> path = new ArrayList<>();
    Position current = endPos;
    
    // ุชุชุจุน ุงูุฃุจ ูู ุงูููุงูุฉ ููุจุฏุงูุฉ
    while (current != null) {
        path.add(0, current);
        current = parentMap.get(posToKey(current));
    }
    
    return path;
}
```

### ุงูุฎุตุงุฆุต:
- โ **ูุณุชูุดู ุจุนุฑุถ** - ูุฒูุฑ ุฌููุน ุงูุฎูุงูุง ุนูู ููุณ ุงููุณุชูู ุฃููุงู
- โ **ูุนุทู ุฃูุตุฑ ูุณุงุฑ** - ูุถูู ุงููุตูู ูุฃูุตุฑ ูุณุงุฑ ูููู
- โ **ูุณุชุฎุฏู Parent Tracking** - ูุญูุธ "ุงูุฃุจ" ููู ุฎููุฉ ูุฅุนุงุฏุฉ ุจูุงุก ุงููุณุงุฑ
- โ๏ธ **ูุณุชุฎุฏู ุฐุงูุฑุฉ ุฃูุซุฑ** - ูุญูุธ ุฌููุน ุงูุฎูุงูุง ุงููุฒุงุฑุฉ

---

## 3๏ธโฃ Linked List - Sequential Traversal

### ุงููุจุฏุฃ ุงูุฃุณุงุณู
**Sequential Node Connection** - ุฑุจุท ุงูุนูุฏ ุจุดูู ูุชุณูุณู ูู ุงูุจุฏุงูุฉ ููููุงูุฉ

### ููู ูุนูู:

```
ุงูุฎุทูุงุช:
1. ูุจุฏุฃ ูู ููุทุฉ ุงูุจุฏุงูุฉ ููุถูููุง ูุฃูู ุนูุฏุฉ (index = 0)
2. ูุฃุฎุฐ ุงูุนูุฏุฉ ุงูุญุงููุฉ ุจูุงุกู ุนูู index
3. ููุญุต ุงูุฌูุฑุงู
4. ุฅุฐุง ูุฌุฏูุง ุฌุงุฑ ุตุงูุญ:
   - ูุถููู ูุนูุฏุฉ ุฌุฏูุฏุฉ ูู ุงูููุงูุฉ
   - ูุฒูุฏ index ููุงูุชูุงู ููุนูุฏุฉ ุงูุชุงููุฉ
5. ุฅุฐุง ูู ูุฌุฏ ุฌูุฑุงู:
   - ูุฑุฌุน index ููุฎูู (Backtrack)
   - ูุฑุฌุน ููุนูุฏุฉ ุงูุณุงุจูุฉ
6. ููุฑุฑ ุญุชู ูุตู ููููุงูุฉ ุฃู ููุดู
```

### ุงูููุฏ:

```java
private boolean stepLinkedList() {
    if (linkedList.isEmpty() || linkedListCurrentIndex >= linkedList.size()) {
        algorithmState = AlgorithmState.NO_PATH;
        return false;
    }

    // ุงูุญุตูู ุนูู ุงูุนูุฏุฉ ุงูุญุงููุฉ (ุจูุงุกู ุนูู index)
    Position current = linkedList.get(linkedListCurrentIndex);

    // ุงูุชุญูู ูู ุงููุตูู ููููุงูุฉ
    if (current.getX() == end.getX() && current.getY() == end.getY()) {
        // ุฑุณู ุงููุณุงุฑ ูู ุงูุจุฏุงูุฉ ุญุชู index ุงูุญุงูู
        for (int i = 0; i <= linkedListCurrentIndex; i++) {
            updateCellState(linkedList.get(i).getX(), 
                           linkedList.get(i).getY(), 
                           CellState.PATH);
        }
        return false;
    }

    List<Position> neighbors = getNeighbors(current);

    if (!neighbors.isEmpty()) {
        // ุฅุถุงูุฉ ุนูุฏุฉ ุฌุฏูุฏุฉ ูู ุงูููุงูุฉ
        Position next = neighbors.get(0);
        linkedList.add(next);
        linkedListCurrentIndex++;  // ุงูุงูุชูุงู ููุฃูุงู
        
        return true;
    } else {
        // Backtrack: ุงูุฑุฌูุน ููุนูุฏุฉ ุงูุณุงุจูุฉ
        if (linkedListCurrentIndex > 0) {
            linkedListCurrentIndex--;  // ุชูููู index
            return true;
        }
        return false;
    }
}
```

### ุงูุฎุตุงุฆุต:
- โ **ููุซู ุฑุจุท ุงูุนูุฏ** - ูู ุนูุฏุฉ ูุฑุชุจุทุฉ ุจุงูุชู ูุจููุง
- โ **ูุณุชุฎุฏู Backtracking** - ูุซู Stack ููู ุจุทุฑููุฉ ูุฎุชููุฉ
- โ **ุงููุณุงุฑ ูู ุงูู List** - ุนูุฏ ุงููุตูู ููููุงูุฉุ ุงูู List ูู ุงูุจุฏุงูุฉ ุญุชู index ุงูุญุงูู ูุญุชูู ุนูู ุงููุณุงุฑ
- โ **ูุณุชุฎุฏู ุฐุงูุฑุฉ ุฃูู** - ูุซู Stack

---

## 4๏ธโฃ A* Algorithm (AI) - A* Search

### ุงููุจุฏุฃ ุงูุฃุณุงุณู
**Heuristic Search** - ุจุญุซ ุฐูู ูุณุชุฎุฏู ุฏุงูุฉ heuristic ูุชูุฏูุฑ ุงููุณุงูุฉ ููููุงูุฉ

### ุงููุนุงุฏูุฉ ุงูุฃุณุงุณูุฉ:
```
f(n) = g(n) + h(n)

ุญูุซ:
- g(n) = ุงูุชูููุฉ ุงููุนููุฉ ูู ุงูุจุฏุงูุฉ ููุนูุฏุฉ ุงูุญุงููุฉ
- h(n) = ุงูุชูููุฉ ุงูููุฏุฑุฉ ูู ุงูุนูุฏุฉ ุงูุญุงููุฉ ููููุงูุฉ (Heuristic)
- f(n) = ุงูุชูููุฉ ุงูุฅุฌูุงููุฉ ุงูููุฏุฑุฉ
```

### ููู ูุนูู:

```
ุงูุฎุทูุงุช:
1. ูุจุฏุฃ ูู ููุทุฉ ุงูุจุฏุงูุฉ ููุญุณุจ f(n) = g(n) + h(n)
2. ูุถุน ุงูุจุฏุงูุฉ ูู Priority Queue (ูุฑุชุจุฉ ุญุณุจ f(n))
3. ูุฃุฎุฐ ุงูุนูุฏุฉ ุฐุงุช ุฃูู f(n) ูู Priority Queue
4. ููุญุต ุฌููุน ุงูุฌูุฑุงู
5. ููู ุฌุงุฑ:
   - ูุญุณุจ g(n) ุงูุฌุฏูุฏ (g(current) + 1)
   - ูุญุณุจ h(n) (ุงููุณุงูุฉ ุงูููุฏุฑุฉ ููููุงูุฉ)
   - ูุญุณุจ f(n) = g(n) + h(n)
   - ุฅุฐุง ูุงู f(n) ุฃูุถู ูู ุงูุณุงุจูุ ูุถููู ููู Priority Queue
6. ููุฑุฑ ุญุชู ูุตู ููููุงูุฉ
7. ูุนูุฏ ุจูุงุก ุงููุณุงุฑ ุจุงุณุชุฎุฏุงู Parent Map
```

### ุงูููุฏ:

```java
// Heuristic function: Manhattan Distance
private double heuristic(Position a, Position b) {
    return Math.abs(a.getX() - b.getX()) + Math.abs(a.getY() - b.getY());
}

private boolean stepAStar() {
    if (openSet.isEmpty()) {
        algorithmState = AlgorithmState.NO_PATH;
        return false;
    }

    // ุงูุญุตูู ุนูู ุงูุนูุฏุฉ ุฐุงุช ุฃูู f(n) ูู Priority Queue
    AStarNode current = openSet.poll();
    Position currentPos = current.getPosition();
    String currentKey = posToKey(currentPos);

    // ููู ูู open set ุฅูู closed set
    closedSet.add(currentKey);

    // ุงูุชุญูู ูู ุงููุตูู ููููุงูุฉ
    if (currentPos.getX() == end.getX() && currentPos.getY() == end.getY()) {
        // ุฅุนุงุฏุฉ ุจูุงุก ุงููุณุงุฑ
        List<Position> path = reconstructAStarPath(currentPos);
        for (Position pos : path) {
            updateCellState(pos.getX(), pos.getY(), CellState.PATH);
        }
        return false;
    }

    // ุงุณุชูุดุงู ุงูุฌูุฑุงู
    List<Position> neighbors = getNeighborsForAStar(currentPos);
    for (Position neighbor : neighbors) {
        String neighborKey = posToKey(neighbor);
        
        if (closedSet.contains(neighborKey)) continue;
        
        // ุญุณุงุจ g(n) ุงูุฌุฏูุฏ
        double tentativeG = gScore.get(currentKey) + 1.0;
        
        // ุฅุฐุง ูุงู ุงููุณุงุฑ ุฃูุถูุ ุชุญุฏูุซู
        if (tentativeG < gScore.getOrDefault(neighborKey, Double.MAX_VALUE)) {
            aStarParentMap.put(neighborKey, currentPos);
            gScore.put(neighborKey, tentativeG);
            
            // ุญุณุงุจ f(n) = g(n) + h(n)
            double h = heuristic(neighbor, end);
            double f = tentativeG + h;
            
            // ุฅุถุงูุฉ ููู Priority Queue
            openSet.add(new AStarNode(neighbor, tentativeG, h));
        }
    }

    return !openSet.isEmpty();
}
```

### ุงูุฎุตุงุฆุต:
- โ **ุฐููุฉ** - ุชุณุชุฎุฏู heuristic ูุชูุฌูู ุงูุจุญุซ
- โ **ูุซูู** - ุชุฌุฏ ุฃูุตุฑ ูุณุงุฑ (ุฅุฐุง ูุงู h(n) admissible)
- โ **ูุนุงูุฉ** - ุชุฒูุฑ ุฎูุงูุง ุฃูู ูู BFS ุนุงุฏุฉ
- โ **AI Algorithm** - ุชุนุชุจุฑ ุฎูุงุฑุฒููุฉ ุฐูุงุก ุงุตุทูุงุนู
- โ๏ธ **ุฃูุซุฑ ุชุนููุฏุงู** - ุชุญุชุงุฌ ุญุณุงุจ heuristic

---

## ๐ ุงูููุงุฑูุฉ ุงูุดุงููุฉ

| ุงูููุฒุฉ | Stack (DFS) | Queue (BFS) | Linked List | A* (AI) |
|--------|-------------|-------------|-------------|---------|
| **ุงููุจุฏุฃ** | LIFO | FIFO | Sequential | Heuristic |
| **ุงูุจููุฉ** | List (ุงูููุงูุฉ) | List (ุงูุจุฏุงูุฉ) | List + Index | Priority Queue |
| **ุงูุงุณุชูุดุงู** | ุนููู | ุนุฑูุถ | ุนููู | ุฐูู |
| **ุงููุณุงุฑ** | ุฃู ูุณุงุฑ | ุฃูุตุฑ ูุณุงุฑ | ุฃู ูุณุงุฑ | ุฃูุตุฑ (ูุซูู) |
| **Backtracking** | ูุนู | ูุง | ูุนู | ูุง |
| **Parent Tracking** | ูุง | ูุนู | ูุง | ูุนู |
| **Heuristic** | ูุง | ูุง | ูุง | ูุนู |
| **ุงูุฐูุงุก** | โ | โ | โ | โ |
| **ุงูุฐุงูุฑุฉ** | ุฃูู | ุฃูุซุฑ | ุฃูู | ูุชูุณุท |
| **ุงูุณุฑุนุฉ** | ุฃุณุฑุน | ุฃุจุทุฃ | ุฃุณุฑุน | ูุชูุณุท |

---

## ๐ป ุงูููุฏ ุงููุงูู ููู ุฎูุงุฑุฒููุฉ

### Stack (DFS):
```java
// Push
stack.add(position);

// Pop
stack.remove(stack.size() - 1);

// Top
stack.get(stack.size() - 1);
```

### Queue (BFS):
```java
// Enqueue
queue.add(neighbor);
parentMap.put(key, current);

// Dequeue
queue.remove(0);

// Front
queue.get(0);
```

### Linked List:
```java
// Add Node
linkedList.add(next);
linkedListCurrentIndex++;

// Backtrack
linkedListCurrentIndex--;

// Current Node
linkedList.get(linkedListCurrentIndex);
```

### A* (AI):
```java
// Heuristic
double h = heuristic(current, end);

// Add to Priority Queue
openSet.add(new AStarNode(neighbor, g, h));

// Get best node
AStarNode current = openSet.poll();

// Update g score
gScore.put(key, tentativeG);
```

---

## ๐ ูุชู ูุณุชุฎุฏู ูู ุฎูุงุฑุฒููุฉุ

### ุงุณุชุฎุฏู Stack (DFS) ุนูุฏูุง:
- ุชุฑูุฏ ุญู ุณุฑูุน
- ุงููุชุงูุฉ ุจุณูุทุฉ
- ูุง ุชุญุชุงุฌ ูุฃูุตุฑ ูุณุงุฑ
- ุงูุฐุงูุฑุฉ ูุญุฏูุฏุฉ

### ุงุณุชุฎุฏู Queue (BFS) ุนูุฏูุง:
- ุชุญุชุงุฌ ูุฃูุตุฑ ูุณุงุฑ
- ุชุฑูุฏ ุงุณุชูุดุงู ุฌููุน ุงูุฎูุงุฑุงุช
- ุงููุชุงูุฉ ูุนูุฏุฉ
- ุงูุฐุงูุฑุฉ ูุชููุฑุฉ

### ุงุณุชุฎุฏู Linked List ุนูุฏูุง:
- ุชุฑูุฏ ููู ููููู ุฑุจุท ุงูุนูุฏ
- ุชุฑูุฏ ุณููู ูุดุงุจู ููู Stack ููู ุจุชูุซูู ูุฎุชูู
- ุชุฑูุฏ ุชูุซูู ุงููุณุงุฑ ูุณูุณูุฉ ูู ุงูุนูุฏ

### ุงุณุชุฎุฏู A* (AI) ุนูุฏูุง:
- ุชุญุชุงุฌ ุฃูุตุฑ ูุณุงุฑ
- ุชุฑูุฏ ุชุทุจูู AI ูู ุงููุดุฑูุน
- ุชุฑูุฏ ููุงุกุฉ ุฃูุถู ูู BFS
- ุงููุชุงูุฉ ูุนูุฏุฉ ูุชุญุชุงุฌ ุจุญุซ ุฐูู

---

## โ ุงูุชุญูู ูู ุงูุตุญุฉ

ุฌููุน ุงูุฎูุงุฑุฒููุงุช ุงูุฃุฑุจุน ุชู ุงูุชุญูู ูููุง ูุชุนูู ุจุดูู ุตุญูุญ:

1. โ **Stack (DFS)**: ูุณุชุฎุฏู LIFO ุจุดูู ุตุญูุญุ ุงููุณุงุฑ ูู ุงูู Stack
2. โ **Queue (BFS)**: ูุณุชุฎุฏู FIFO ุจุดูู ุตุญูุญุ Parent Map ูุฅุนุงุฏุฉ ุจูุงุก ุงููุณุงุฑ
3. โ **Linked List**: ููุซู ุฑุจุท ุงูุนูุฏ ุจุดูู ูุชุณูุณู
4. โ **A* (AI)**: ุฎูุงุฑุฒููุฉ ุจุญุซ ุฐููุฉ ุชุณุชุฎุฏู heuristic function ุจุดูู ุตุญูุญ

---

**ุชู ุฅูุดุงุก ูุฐุง ุงูููู ุจูุงุณุทุฉ: Auto AI Assistant**
**ุชุงุฑูุฎ ุงูุชุญุฏูุซ: 2024**

